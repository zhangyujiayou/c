#define _CRT_SECURE_NO_WARNINGS 1
#include<stdio.h>
#include<string.h>
//int main()
//{
//	printf("hehe\n");
//	printf("hehe\n");
//	printf("hehe\n");
//	printf("hehe\n");
//	printf("hehe\n");
//	printf("hehe\n");
//	return 0;
//}


 //局部变量的作用域：是在局部变量所在的局部范围
//int main()
//{
//	    //字符串的结束标志：‘\0’
//		//"abcdef"
//		//'\0' - 转义字符 - 对应的ASCII值是0
//		//0->数字0
//		//'0'->字符0 - 对应的ASCII值是48
//		//'a' 'b' 'c' '0' '1' '2' '3'
//	    //EOF-end of file-文件结束标志-  -1
//		return 0;
//}
 
 //写求两个数的较大值
//int main()
//{
//	int num1 = 0;
//	int num2 = 0;
//	int max = 0;
//	scanf("%d%d", &num1, &num2);
//	if (num1 >= num2)
//		printf("max=%d", num1);
//	else
//		printf("max=%d", num2);
//	return 0;	
//}
 

//写一个函数求两个数的较大值
//int Max(int x,int y)
//{
//	if (x > y)
//		return x;
//	else
//		return y;
//}
//int main()
//{
//	int num1 = 0;
//	int num2 = 0;
//	int max = 0;
//	int i = 0;
//	scanf("%d%d", &num1, &num2);
//	max = Max(num1, num2);
//	for (i = 0; i < 100; i++)
//	{
//		printf("较大值为%d\n", max);
//		printf("次数为%d\n", i);
//	}
//	return 0;
//}

//int main()
//{
//	int a = 10;
//	int arr[] = { 1, 2, 3, 4, 5, 6 };//6*4=24--> int[6]
//	printf("%d\n", sizeof(a));//4
//	printf("%d\n", sizeof(int));//4
//	printf("%d\n", sizeof(arr));//计算数组大小，单位是字节
//	printf("%d\n", sizeof(arr)/sizeof(arr[0]));//计算每个元素的大小
//	return 0;
//}

//~表示按位取反的意思
//int main()
//{
//	int a = 0;
//	int b = ~a;
//	//a的原码=00000000 00000000 00000000 00000000
//	//~a以后得到的是11111111 11111111 11111111 11111111（计算机识别出来它是负数）
//	//负数在内存中存储的时候，存储的是二进制的补码
//	//这个时候计算机认为他是b的补码
//	//原码，反码，补码
//	//所以补码减一得到反码，在符号位不变其余取反得到了计算机认为的原码
//	//11111111 11111111 11111111 11111111
//	//11111111 11111111 11111111 11111110
//	//10000000 00000000 00000000 00000001
//	//这个时候计算机就认为上面的数据就是b的原码
//	printf("%d\n", b);//这里打印出来的是b的原码，所以b=-1
//	return 0;
//}

//原码、反码、补码知识整理
//
//在计算机中机器是识别不了正数(+)、负数(-)的，所以早期给计算机设定了0代表正数， 1代表负数，称为符号位，置于最前面
//
//1.原码
//正数转换为二进制数，二进制数就是这个正数的原码
//负数取绝对值转换为二进制位，二进制位在最高位补1就是这个负数的原码
//eg：int(3)的原码为多少？
//解析
//3转换为二进制位为：11B，在32位机器上占4个字节，补零
//原码：00000000 00000000 00000000 00000011
//- 3取绝对值后转换为二进制位为：11B，在32位机器上占4个字节，在最高位补1
//原码：10000000 00000000 00000000 00000011
//
//2.反码
//正数的反码跟原码相同
//负数的反码为在原码的基础上，除符号位外所有位取反，即1变0, 0变1
//eg：int(3)的反码为多少？
//解析
//3转换为二进制位为：11B，在32位机器上占4个字节，补零
//原码：00000000 00000000 00000000 00000011
//- 3取绝对值后转换为二进制位为：11B，在32位机器上占4个字节，在最高位补1，除符号位外所有位取反
//原码：10000000 00000000 00000000 00000011
//反码：11111111 11111111 11111111 11111100
//
//3.补码
//正数的补码跟原码相同
//负数的补码为在原码基础上，除符号位外所有位取反（得到反码），最后在最低位 + 1
//eg：int(3)的补码为多少？
//解析
//3转换为二进制位为：11B，在32位机器上占4个字节，补零
//正数：00000000 00000000 00000000 00000011
//- 3取绝对值后转换为二进制位为：11B，在32位机器上占4个字节，在最高位补1，除符号位外所有位取反
//原码：10000000 00000000 00000000 00000011
//反码：11111111 11111111 11111111 11111100
//补码：11111111 11111111 11111111 11111101
//也可以说在负数的补码=反码+1
//
//
//
//总结：
//1.正数的反码和补码与原码相同
//2.负数的反码为这个数的原码除符号位外所有位取反
//3.负数的补码为这个数的原码除符号位外所有位取反(即得到反码)，然后在最后一位加1


//int main()
//{
//	int a = 10;
//	//int b = a++;//后置加加，先使用，在++、11、10
//	//int b=++a;//前置加加，先++，在使用、11、11
//	//int b = a--;//后置减减，先使用，在--、9、10
//	//int b = --a;//前置减减，先--，在使用、9、9
//	printf("a=%d b=%d\n", a,b);
//	return 0;
//}


//int main()
//{
//	//真-非0
//	//假-0
//	//&&-逻辑与
//	//||-逻辑或
//	int a = 3;
//	int b = 5;
//	//int c = a&&b;
//	int c = a || b;
//	printf("c=%d\n", c);
//	return 0;
//}


//条件操作符
//exp1?exp2:exp3-exp-表达式 
//int main()
//{
//	int a = 100;
//	int b = 20;
//	int max = 0;
//
//	max = (a > b ? a : b);
//	/*if (a > b)
//		max = a;
//	else
//		max = b;*/
//	printf("%d\n", max);
//	return 0;
//}

//int ADD(int x,int y)
//{
//	int z = 0;
//	z = x + y;
//	return z;
//}
//int main()
//{
//	//int arr[10] = { 0 };
//	//arr[4];//[]-下标引用操作符
//	int a = 10;
//	int b = 60;
//	int sum = ADD(a,b);//()-函数调用操作符
//	printf("%d\n", sum);
//	return 0;
//}

//&,*,.,->,  还有这些操作符

//static 修饰局部变量表示一个静态的局部变量。
//意味着局部变量的生命周期边长，因为静态就意味着永恒。
//void test()
//{
//	static int a = 1;//a是一个静态的局部变量
//	a++;
//	printf("%d\n", a);//2,3,4,5,6
//}
//int main()
//{
//	int i = 0;
//	while (i < 5)
//	{
//		test();
//		i++;
//	}
//	return 0;
//}

//static修饰全局变量
//改变了变量的作用域，让静态的全局变量只能够作用在自己所在的源文件内部使用
//出了自己的源文件内部就无法使用。

//static修饰函数
//也是改变了函数的作用域--这种说发不准确
//static修饰函数改变了函数的链接属性
//外部链接属性->内部链接属性


//#define 定义标识符常量
//#define MAX 100（表示MAX就是100，注意中间不需要等号）
//#define 可以定义宏--带参数
//#define MAX(X,Y) (X>Y?X:Y) -- 表示MAX(X,Y)就是(X>Y?X:Y)


//int main()
//{
//	int a = 10;//4个字节
//	int* p = &a;//取地址
//	*p = 20;//*-解引用操作符
//	printf("%d\n", a);
//	return 0;
//}


//int main()
//{
//	char ch = 'w';
//	char* pc = &ch;
//	*pc = 'a';
//	printf("%c\n", ch);
//	printf("%d\n", sizeof(pc));//可以看出是用4个字节来存放地址的。
//	return 0;
//}
//32位的存放指针地址需要4个字节，64位的存放指针地址需要8个字节。


//int main()
//{
//	double d = 3.14;
//	double* pd = &d;//pd是一个变量-指针变量
//	*pd = 8.76;
//	printf("%lf\n", d);
//	printf("%lf\n", *pd);
//	printf("%p\n", &d);//找到d所在的32位-4字节的地址  
//
//
//	//int a = 10;
//	///*printf("%p\n", &a);*/
//	//int* p = &a;//p是一个变量-指针变量
//	//*p = 20;
//	//printf("%d\n", a);
//	return 0;
//}


//一个复杂的东西利用结构体来描述。
//关键词struct
//ep描述一本书
//struct Book
//{
//	char name[20];//C语言程序设计
//	short price;//55
//};
//int main()
//{
//	//利用结构体类型--创建一个该类型的结构体变量
//	struct Book b1 = { "C语言程序设计",55 };
//	strcpy(b1.name, "c++语言设计");//strcpy-string copy-字符串拷贝。需要使用到库函数string.h,所以需要打招呼，就要头文件。#include<string.h>
//	printf("%s\n", b1.name);
//
//	/*struct Book* pb = &b1;*/
//	//利用指针变量pb打印书名和价格
//	//.应用到结构体变量上可以找到成员
//	//->应用到结构体指针指向成员 
//
//	/*printf("%s\n", (*pb).name);     //第一种写法
//	printf("%d\n", (*pb).price);*/
//
//	//printf("%s\n", pb->name);         //第二种写法
//	//printf("%d\n", pb->price);        
//
//
//	//printf("书名：%s\n", b1.name);
//	//printf("价格为%d元\n", b1.price);
//	//b1.price = 67;
//	//printf("修改以后的价格为%d元\n", b1.price);
//	return 0;
//}

  



